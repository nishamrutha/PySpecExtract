#!/usr/bin/env python

"""
This module defines a class called SpecExtract that facilitates the extraction
 of spectral data from FITS files generated by PyWiFeS data reduction.
 The module provides methods to create aperture masks for object and sky regions,
 generate the spectrum, save it as a MARZ friendly FITS file, and plot the spatial
 and spectral data.

This module is developed as a backend to the PySpecExtract GUI to easily select object
 and sky regions, but can be run independently in a python command line environment.

Version 2.0 includes psf fitting.
"""

#############
#  Imports  #
#############
import glob
import os

# import matplotlib.dates as md
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from astropy.io import fits
# from astropy.time import Time
from matplotlib import rcParams
from mpl_toolkits.axes_grid1 import make_axes_locatable
from psf_fit import PsfFit

##############
# Authorship #
##############
__author__ = "Neelesh Amrutha"
__date__ = "03 December 2025"

__license__ = "GPL-3.0"
__version__ = "2.0"
__maintainer__ = "Neelesh Amrutha"
__email__ = "neelesh.amrutha<AT>anu.edu.au"

##########################
#  Plotting environment  #
##########################

# Plotting options
rcParams['font.size'] = 11

# Set default linewidth
rcParams['lines.linewidth'] = 1.0
rcParams['axes.linewidth'] = 0.8

# X-axis style
rcParams['xtick.top'] = True
rcParams['xtick.direction'] = 'in'
rcParams['xtick.minor.visible'] = True
rcParams['xtick.major.size'] = 4
rcParams['xtick.minor.size'] = 3
rcParams['xtick.major.width'] = 0.75
rcParams['xtick.minor.width'] = 0.25
rcParams['xtick.major.pad'] = 4
rcParams['xtick.minor.pad'] = 4

# Y-axis style
rcParams['ytick.right'] = True
rcParams['ytick.direction'] = 'in'
rcParams['ytick.minor.visible'] = True
rcParams['ytick.major.size'] = 4
rcParams['ytick.minor.size'] = 3
rcParams['ytick.major.width'] = 0.75
rcParams['ytick.minor.width'] = 0.25
rcParams['ytick.major.pad'] = 4
rcParams['ytick.minor.pad'] = 4

# Legend style
rcParams['legend.fontsize'] = 7
rcParams['legend.labelspacing'] = 0.2
rcParams['legend.loc'] = 'best'
rcParams['legend.frameon'] = False

# Figure layout
rcParams['savefig.bbox'] = 'tight'

###############
#  Constants  #
###############
edge_trim = 3  # remove edge from n_row for bad pixel rows in WiFeS
n_row, n_col = 38 - edge_trim, 25  # WiFeS cube face dimensions
sep = 5650  # WiFeS blue/red separation wavelength
full_min, full_max = 3800, 7800  # WiFeS spectrum range (blue + red)


############################################################################################

class SpecExtract:
    """
    SpecExtract is a class for extracting spectral data from FITS files
    generated from PyWiFeS data reduction.

    Parameters:
        obj_name (str): Name of the object.
        red_f (str): File path to the red FITS file.
        blue_f (str): File path to the blue FITS file.
        **kwargs: Additional keyword arguments to set custom attributes.

    Attributes:
        obj_name (str): Name of the object.
        red_hdu (HDUList): HDUList object for the red FITS file.
        blue_hdu (HDUList): HDUList object for the blue FITS file.
        blue (ndarray): Extracted blue data from the FITS file.
        blue_e (ndarray): Extracted blue variance from the FITS file.
        blue_head (Header): Header information for the blue side.
        wave_blue (ndarray): Wavelength values for the blue side.
        blue_ind (ndarray): Indices of the wavelength values within a desired range.
        red (ndarray): Extracted red data from the FITS file.
        red_e (ndarray): Extracted red error data from the FITS file.
        red_head (Header): Header information for the red side.
        wave_red (ndarray): Wavelength values for the red side.
        red_ind (ndarray): Indices of the wavelength values within a desired range.
        obs_red (str): Observation date of red image
        obs_blue (str): Observation date of blue image
        obs_mjd (float): Observation date in modified Julian date (MJD) (blue).
        sky_r (int): Sky aperture radius.
        row (int): Aperture row position.
        col (int): Aperture column position.
        row_min (int): Sky row position.
        col_min (int): Sky column position.
        mask_min: Sky mask.
        spec_wifes_raw: Extracted WiFeS spectrum.
        spec_wifes_err: Error in WiFeS spectrum (standard deviation).
        wave_wifes: Wavelength values for WiFeS spectrum.

    Methods:
        make_mask: Create aperture masks for object and sky subtraction regions.
        generate_spec: Generate the spectrum and save it as a FITS file.
        plot_spatial: Plot the spatial image marking aperture and sky regions.
        plot_spec: Plot the spectrum with standard deviation error.
    """

    def __init__(self, obj_name, red_f, blue_f, **kwargs):

        self.obj_name = obj_name
        print(f"Loading {obj_name}...")

        # Open red and blue FITS files
        self.red_hdu = fits.open(red_f)
        self.blue_hdu = fits.open(blue_f)

        ''' Blue '''
        self.blue = self.blue_hdu[0].data[:, edge_trim:, :]  # Remove bad pixel rows
        self.blue_e = self.blue_hdu[1].data[:, edge_trim:, :]
        self.blue_head = self.blue_hdu[0].header
        self.wave_blue = self.blue_head['CRVAL3'] + np.arange(len(self.blue)) * self.blue_head['CDELT3']
        self.blue_ind = np.ravel(np.argwhere((self.wave_blue > full_min) & (self.wave_blue <= sep)))
        self.img_type = self.blue_head['WIFESOBS']
        print(f"Observation type: {self.img_type}")

        ''' Red '''
        self.red = self.red_hdu[0].data[:, edge_trim:, :]  # Remove bad pixel rows
        self.red_e = self.red_hdu[1].data[:, edge_trim:, :]
        self.red_head = self.red_hdu[0].header
        self.wave_red = self.red_head['CRVAL3'] + np.arange(len(self.red)) * self.red_head['CDELT3']
        self.red_ind = np.ravel(np.argwhere((self.wave_red > sep) & (self.wave_red <= full_max)))

        '''Splice'''
        self.splice_cube = np.zeros((len(self.blue_ind) + len(self.red_ind), n_row, n_col))
        self.splice_cube[0:len(self.blue_ind), :, :] = self.blue[self.blue_ind, :, :]
        self.splice_cube[len(self.blue_ind):, :, :] = self.red[self.red_ind, :, :]
        self.splice_err = np.zeros((len(self.blue_ind) + len(self.red_ind), n_row, n_col))
        self.splice_err[0:len(self.blue_ind), :, :] = self.blue_e[self.blue_ind, :, :]
        self.splice_err[len(self.blue_ind):, :, :] = self.red_e[self.red_ind, :, :]
        self.wave_wifes = np.concatenate((self.wave_blue[self.blue_ind], self.wave_red[self.red_ind]))
        self.splice_image = np.nanmedian(self.splice_cube, axis=0)

        # Observed dates
        self.obs_red = self.red_head['DATE-OBS']
        self.obs_blue = self.blue_head['DATE-OBS']
        self.obs_mjd = self.blue_head['MJD-OBS']

        # Aperture position
        self.row = 10
        self.col = 12

        # Sky
        self.sky_r = 3  # sky aperture radius

        # Disjoint sky position
        self.row_min = 30
        self.col_min = 12

        # Placeholders for masks and data arrays
        self.mask_min = None
        self.splice_cube_skysub = None
        self.splice_err_skysub = None
        self.spec_wifes_raw = None
        self.spec_wifes_err = None
        self.psf_fit = None
        self.model_type = 'moffat'  # PSF model type

        # Set kwargs attributes
        for key, value in kwargs.items():
            setattr(self, key, value)

        if self.model_type == 'moffat':
            self.psf_labs = ['_amp', '_x0', '_y0', '_ax', '_ay', '_bet', 'thet', 'ofst']
            self.psf_keys = ['amp', 'x0', 'y0', 'alpha_x', 'alpha_y', 'beta', 'theta', 'offset']
        elif self.model_type == 'gaussian':
            self.psf_labs = ['_amp', '_x0', '_y0', '_sx', '_sy', 'thet', 'ofst']
            self.psf_keys = ['amp', 'x0', 'y0', 'sigma_x', 'sigma_y', 'theta', 'offset']
        else:
            self.psf_labs = []
            self.psf_keys = []

        # Close FITS
        self.red_hdu.close()
        self.blue_hdu.close()

    def make_mask(self):
        """
        Method to create aperture mask for sky subtraction regions.
        """
        x, y = np.ogrid[-self.row_min:n_row - self.row_min, -self.col_min:n_col - self.col_min]
        self.mask_min = x * x + y * y <= self.sky_r ** 2

    def generate_spec(self, save_loc="WiFeS_with_error/", save=True, init=False):
        """
        Method to generate the spectrum and save it as a FITS file.

        :param save_loc: Location to save the FITS file.
        :param save: Boolean flag to indicate whether to save the FITS file or not.
        :param init: Do not fit psf in first instance
        """
        self.make_mask()  # generate aperture and sky mask

        if init:
            # Spliced sky
            sky_mean = np.mean(self.splice_cube[:, self.mask_min], axis=1)
            sky_error = np.mean(self.splice_err[:, self.mask_min], axis=1) / np.sqrt(
                self.splice_err[:, self.mask_min].shape[1])

            # Handle case of zero sky radius
            if self.sky_r == 0:
                sky_mean = np.zeros_like(sky_mean)
                sky_error = np.zeros_like(sky_error)

            # Sky subtracted cube
            self.splice_cube_skysub = self.splice_cube - sky_mean[:, None, None]
            self.splice_err_skysub = self.splice_err + sky_error[:, None, None]

            # Extract from one pixel
            self.spec_wifes_raw = self.splice_cube_skysub[:, self.row, self.col]
            self.spec_wifes_err = np.sqrt(self.splice_err_skysub[:, self.row, self.col])
        else:
            # Spliced sky
            sky_mean = np.mean(self.splice_cube[:, self.mask_min], axis=1)
            sky_error = np.mean(self.splice_err[:, self.mask_min], axis=1) / np.sqrt(
                self.splice_err[:, self.mask_min].shape[1])

            # Handle case of zero sky radius
            if self.sky_r == 0:
                sky_mean = np.zeros_like(sky_mean)
                sky_error = np.zeros_like(sky_error)

            # Sky subtracted cube
            self.splice_cube_skysub = self.splice_cube - sky_mean[:, None, None]
            self.splice_err_skysub = self.splice_err + sky_error[:, None, None]

            self.psf_fit = PsfFit(self.splice_cube_skysub, self.splice_err_skysub, self.row, self.col, self.model_type)
            self.spec_wifes_raw = self.psf_fit.extracted_spectrum
            self.spec_wifes_err = self.psf_fit.extracted_error

        # Save MARZ-friendly FITS
        if save:
            # FITS header dictionary
            cat = {'OBJECT': self.obj_name,
                   'RA': self.red_head['RA'],
                   'DEC': self.red_head['DEC'],
                   'EXPTIME': self.red_head['EXPTIME'],
                   'AIRMASS': self.red_head['AIRMASS'],
                   'IMAGETYP': self.img_type,
                   'GRATINGR': self.red_head['GRATINGR'],
                   'GRATINGB': self.blue_head['GRATINGB'],
                   'BEAMSPLT': self.red_head['BEAMSPLT'],
                   'APTWHEEL': self.red_head['APTWHEEL'],
                   'DATA': "INTENSITY",
                   'DAT_UNIT': "erg s^-1 cm^-2 Angstrom^-1",
                   'OBS_RED': self.obs_red,  # Save dates
                   'OBS_BLUE': self.obs_blue,
                   'OBS_MJD': self.obs_mjd,  # observed MJD
                   'row_sky': self.row_min + edge_trim,  # de-offset bad rows when saving
                   'col_sky': self.col_min,
                   'sky_rad': self.sky_r,
                   'PSF_MOD': self.model_type
                   }

            # Additional PSF fitting parameters to header
            for i in range(len(self.psf_fit.fit_results)):
                pars = self.psf_fit.fit_results[i]['params']
                errs = self.psf_fit.fit_results[i]['errors']
                for j in range(len(self.psf_keys)):
                    key = self.psf_keys[j]
                    lab = self.psf_labs[j]
                    cat[f'PSF{i}{lab}'] = pars[key] + edge_trim if key == 'y0' else pars[key]
                    cat[f'ERR{i}{lab}'] = errs[key + '_err']

            hdu = fits.PrimaryHDU(self.spec_wifes_raw)  # intensity array in primary
            hdu.header.update(cat)  # append object details dict to header
            hdu1 = fits.ImageHDU(self.wave_wifes, name='wavelength')  # wavelength array in image extension
            hdu1.header.update({'Unit': 'angstrom'})  # wavelength unit
            hdu2 = fits.ImageHDU(self.spec_wifes_err, name='int_err')  # intensity error
            hdu2.header.update({'Error': '1 sigma', 'Unit': 'erg s^-1 cm^-2 Angstrom^-1'})  # intensity error unit
            fits.HDUList([hdu, hdu1, hdu2]).writeto(f'{save_loc}/{self.obj_name}.fits', overwrite=True)  # write

    def plot_spatial(self, save=False, save_loc='spat_plots/'):
        """
        Method to plot the spatial image with aperture and sky regions.

        :param save: Boolean flag to indicate whether to save the plot or not.
        :param save_loc: Location to save the plot.
        :return: The figure object to display in the GUI.
        """
        self.make_mask()

        # Circles to show aperture and sky on spatial image
        circle = plt.Circle((self.col_min, self.row_min), self.sky_r, color='r', linestyle='--', fill=False)

        # Mark central pixel
        rect = plt.Rectangle((self.col - 0.5, self.row - 0.5), 1, 1, color='r', fill=False)

        ''' Blue '''
        fig, ax_spat = plt.subplots(1, 1)
        divider = make_axes_locatable(ax_spat)
        cax = divider.append_axes('right', size='5%', pad=0.05)
        imb = ax_spat.imshow(self.splice_image)  # edge bad rows at edge not shown
        fig.colorbar(imb, cax=cax, orientation='vertical')
        ax_spat.add_patch(circle)
        ax_spat.add_patch(rect)

        # Save
        if save:
            plt.savefig(save_loc + '/' + self.obj_name + '.pdf')

        # Return figure to plot in GUI section
        return fig

    def plot_spec(self, save=True, save_loc=f"out/spec_plots/"):
        """
        Method to plot the spectrum with error bars.

        :param save: Boolean flag to indicate whether to save the plot or not.
        :param save_loc: Location to save the plot.
        :return: The figure object to display in GUI.
        """
        # Error shading -- y +/- y_std/2
        e_wif = self.spec_wifes_err * 0.5

        # Plot
        fig, ax = plt.subplots(1, 1, figsize=(12.15, 3))
        ax.plot(self.wave_wifes, self.spec_wifes_raw, 'b-',
                linewidth=0.75, label='WiFeS', zorder=2)
        y_lim = ax.get_ylim()

        # Shade error
        ax.fill_between(self.wave_wifes, (self.spec_wifes_raw - e_wif), (self.spec_wifes_raw + e_wif),
                        alpha=0.3, facecolor='r')

        ax.set_ylim(y_lim)

        # Labels
        ax.set_xlabel(r'Wavelength ($\AA$)')
        ax.set_ylabel(r'Flux ($erg\ s^{-1}\ cm^{-2}\ \AA^{-1}$)')
        ax.set_xlim([full_min, full_max])
        ax.legend(loc='upper left', fontsize=10)
        plt.tight_layout()

        # Save
        if save:
            plt.savefig(f'{save_loc}/{self.obj_name}.pdf')

        return fig

    def plot_wavelength_profile(self, save=False, save_loc=f"out/wave_profiles/"):
        """
        :param save: Boolean flag to indicate whether to save the plot or not.
        :param save_loc: Location to save the plot.
        :return: The figure object to display in GUI.
        """
        fig, axs = plt.subplots(3, 1, figsize=(8, 7), sharex=True)

        if self.psf_fit is None:
            print("Spectrum has not been generated yet. Please run generate_spec() first.")

        if self.model_type == 'gaussian':
            arr = np.array([self.psf_fit.x0_arr, self.psf_fit.y0_arr,
                            self.psf_fit.sx_arr, self.psf_fit.sy_arr, self.psf_fit.th_arr])

            # convert sigma to FWHM
            arr[2] = 2.3548 * arr[2]
            arr[3] = 2.3548 * arr[3]
            labs = ['xy', r'FWHM', r'$\theta$']
            legs = [r'$x_0$', r'$y_0$', r'FWHM$_x$', r'FWHM$_y$', r'$\theta$']

            axs[0].plot(self.wave_wifes, arr[0], 'b-', label=legs[0])
            axs[0].set_ylabel(labs[0])
            axs[0].grid()
            axs[0].plot(self.wave_wifes, arr[1], 'r-', label=legs[1])
            axs[0].legend()

            axs[1].plot(self.wave_wifes, arr[2], 'b-', label=legs[2])
            axs[1].set_ylabel(labs[1])
            axs[1].grid()
            axs[1].plot(self.wave_wifes, arr[3], 'r-', label=legs[3])
            axs[1].legend()

            axs[2].plot(self.wave_wifes, arr[4], 'b-', label=legs[4])
            axs[2].set_ylabel(labs[2])
            axs[2].grid()

        elif self.model_type == 'moffat':
            arr = np.array([self.psf_fit.x0_arr, self.psf_fit.y0_arr, self.psf_fit.ax_arr,
                            self.psf_fit.ay_arr, self.psf_fit.be_arr, self.psf_fit.th_arr])
            labs = ['xy', 'FWHM', r'$\beta$ - $\theta$']
            legs = [r'$x_0$', r'$y_0$', r'FWHM$_x$', r'FWHM$_y$', r'$\beta$', r'$\theta$']

            # convert to FWHM
            arr[2] = 2.0 * arr[2] * np.sqrt(2.0 ** (1.0 / arr[4]) - 1.0)
            arr[3] = 2.0 * arr[3] * np.sqrt(2.0 ** (1.0 / arr[4]) - 1.0)

            if self.psf_fit is None:
                print("Spectrum has not been generated yet. Please run generate_spec() first.")
            for i in range(3):
                axs[i].plot(self.wave_wifes, arr[2*i], 'b-', label=legs[2*i])
                axs[i].set_ylabel(labs[i])
                axs[i].grid()
                axs[i].plot(self.wave_wifes, arr[2*i+1], 'r-', label=legs[2*i+1])
                axs[i].legend()
        else:
            print("Unknown model type for PSF fitting.")

        axs[-1].set_xlabel(r'Wavelength ($\mathrm{\AA}$)')
        plt.tight_layout()
        if save:
            plt.savefig(f'{save_loc}/{self.obj_name}.pdf')

        plt.close()

    def plot_model_evaluation(self, save_loc='out/psf_fits'):
        if save_loc:
            self.psf_fit.make_model_evaluation_plot(save=f'{save_loc}/{self.obj_name}.pdf')
        else:
            self.psf_fit.make_model_evaluation_plot(save=False)


def red_blue_filename_sep(obj):
    """
    Pandas group-by helper function to separate blue and red filenames
    from the given dataframe with a single object and all known FITS
    files pertaining to the specific object.

    :param obj: Dataframe containing only one object.
    :return: the obj dataframe condensed into a single Series object.
    """
    result = {'object': obj['object'].values[0]}
    for fn in obj['file']:
        # Get file name
        fits_name = os.path.basename(fn)

        #  Separate blue and red files
        if fits_name.startswith("T2m3w"):
            # For TAROS era files
            if fits_name[5] == 'b':
                result['blue'] = fn
            elif fits_name[5] == 'r':
                result['red'] = fn
            else:
                print("Could not read file: " + fits_name)
        elif fits_name.startswith("OBK"):
            # For Robotic era files
            if 'blue' in fits_name.lower():
                result['blue'] = fn
            elif 'red' in fits_name.lower():
                result['red'] = fn
            else:
                print("Could not read file: " + fits_name)
        elif fits_name.endswith("_R.fits") or fits_name.endswith("_B.fits"):
            # For WiFeS era files
            if fits_name.endswith("_B.fits"):
                result['blue'] = fn
            elif fits_name.endswith("_R.fits"):
                result['red'] = fn
        else:
            print("Could not read file: " + fits_name)
    return pd.Series(result,
                     index=["object", "blue", "red"],
                     dtype="object")


def make_amalgamated_file(raw_dir, check_wifes=True):
    """
    Read directory containing FITS files, or subdirectories containing FITS files
    and save object_fits_list.csv file listing object and blue/red p11 FITS file paths

    :param raw_dir: path to directory containing FITS files
    :param check_wifes: manual check for .fits cubes without WiFeS name
    :return: master list containing object and blue/red p11 FITS file paths
    """
    # Read .p11.fits files in the directory or subdirectories
    if check_wifes:
        raw_file_list = glob.glob(f"{raw_dir}/**/*.p11.fits", recursive=True)
        raw_file_list.extend(glob.glob(f"{raw_dir}/**/*.cube.fits", recursive=True))
    else:
        raw_file_list = glob.glob(f"{raw_dir}/**/*.fits", recursive=True)
    print(f"Found {len(raw_file_list)} files.")

    # Generate object - file relation
    print(f"Generating {raw_dir}/object_fits_list.csv...")
    with (open(f'{raw_dir}/object_fits_list.csv', 'w') as obj_list):
        obj_list.write('file,object,id\n')  # Column names
        for f in raw_file_list:
            fits_name = os.path.basename(f)
            if fits_name.startswith("T2m3w") or fits_name.startswith("OBK") or \
                    fits_name.endswith("_R.fits") or fits_name.endswith("_B.fits"):
                with fits.open(f) as hdu_l:
                    hdr = hdu_l[0].header
                    obj = hdr['OBJECT']
                    ra = hdr['RA']
                    dec = hdr['DEC']
                    mjd = hdr['MJD-OBS']
                    # unique identifier for object
                    id_unique = f"{obj}_{ra}_{dec}_{mjd:.4f}"
                    obj_list.write(f"{f},{obj},{id_unique}\n")
    print("Done")

    # Group file - object relation based on object and separate blue/red file paths
    print(f"Condensing {raw_dir}/object_fits_list.csv...")
    obj_list = pd.read_csv(f'{raw_dir}/object_fits_list.csv')

    # Group by unique id and separate blue/red files
    obj_list = obj_list.groupby(['id'],
                                as_index=False).apply(red_blue_filename_sep,
                                                      include_groups=False).reset_index(drop=True)

    # Number duplicates
    n = obj_list.groupby("object").cumcount()
    obj_list["object"] = obj_list["object"] + np.where(n == 0, "", "_" + (n + 1).astype(str))

    # Sort
    obj_list = obj_list.sort_values(by='id').reset_index(drop=True)

    # Save condensed list
    obj_list.to_csv(f'{raw_dir}/object_fits_list.csv', index=False)
    print("Done")
    print(f"Found {len(obj_list)} unique spectra.")

    return obj_list


# Testing
# spec_extract = SpecExtract("g1007504-090445",
#                            "/Users/neelesh/Desktop/WiFeS_Raw/T2m3wr-20220526.085114-0337.p11.fits",
#                            "/Users/neelesh/Desktop/WiFeS_Raw/T2m3wb-20220526.085114-0337.p11.fits")
# spec_extract = SpecExtract("1254564-265702",
#                            "/Users/neelesh/Desktop/WiFeS_Raw/T2m3wr-20220526.112847-0345.p11.fits",
#                            "/Users/neelesh/Desktop/WiFeS_Raw/T2m3wb-20220526.112848-0345.p11.fits")

# make_amalgamated_file("/Users/neelesh/Desktop/WiFeS_Raw", check_wifes=True)

# spec_extract.plot_spatial(save=False).show()
# spec_extract.generate_spec(save=False)
# spec_extract.plot_spec(save=False).show()
# spec_extract.plot_wavelength_profile(save=False)
# spec_extract.plot_model_evaluation(save_loc=None)
